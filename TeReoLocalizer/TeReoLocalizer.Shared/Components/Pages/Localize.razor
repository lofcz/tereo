@page "/localize"
@page "/"
@using System.Collections.Concurrent
@using System.Runtime.CompilerServices
@using System.Text.RegularExpressions
@using DeepL
@using DeepL.Model
@using Mapster
@using TeReoLocalizer.Annotations
@using TeReoLocalizer.Shared.Code
@using TeReoLocalizer.Shared.Code.Commands
@using TeReoLocalizer.Shared.Code.Services
@using TeReoLocalizer.Shared.Components.Pages.Owned
@using JsonSerializer = System.Text.Json.JsonSerializer
@using Microsoft.AspNetCore.Components.Sections
@inject IJSRuntime Js
@inject IModalService Md
@implements IAsyncDisposable
@inherits ComponentBaseEx

@code {

    public Project Project = new Project();
    public Decl Decl => Project.SelectedDecl;
    public UserSettings Settings = new UserSettings();
    public readonly LangsData LangsData = new LangsData();
    public string NewKey = string.Empty;
    public string? InputToFocus;
    public string? LastFocusedInput { get; set; }
    public string? LastAddedKey { get; set; }
    public string KeySearch = string.Empty;
    public readonly CommandManager CommandManager = new CommandManager();
    public bool JumpingInHistory { get; set; }
    public bool EnableRendering { get; set; } = true;
    public IModalReference? RewindModalRef;
    public bool Translating;
    public int Translated;
    public List<TranslateTaskInput> ToTranslate = [];
    InvertedIndex Index => Program.Index;

    DotNetObjectReference<Localize>? JsRef { get; set; }
    IJSObjectReference? JsObjectRef;
    IJSObjectReference? JsObjectRefNative;

    string langCode = string.Empty;
    string basePath = AppDomain.CurrentDomain.BaseDirectory;
    List<string> existingFiles = [];
    bool showLangs, showLangsSelection, showAddLangs, showGroupSettings;
    bool ready;
    bool synchronizingIndex;
    string id = General.IIID();
    bool jsInitialized;
    List<NativeCommand> nativeCommands = [];
    List<KeyValuePair<string, Key>> visibleKeys = [];
    int keyPages = -1;
    int keySelectedPage = 1;
    ElementReference? jumpToPageInput;
    bool renderSearchModeSelection;
    List<ProjectError>? loadErrors;
    bool projectLoadingFinished;
    bool contentRendered;

    class ProjectError
    {
        public string Message { get; set; }

        public ProjectError(string error)
        {
            Message = error;
        }
    }

    class NativeCommand
    {
        public NativeCommands Type { get; set; }
        public object? Data { get; set; }
    }

    enum NativeCommands
    {
        Unknown,
        SetTextareaHeight
    }

    ProjectCtx GetCtx()
    {
        return new ProjectCtx(Project, Project.SelectedDecl, Settings, LangsData, Js, this);
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();
        JsRef = DotNetObjectReference.Create(this);
    }

    protected override bool ShouldRender()
    {
        return ready && EnableRendering;
    }

    void Panic(string message)
    {
        projectLoadingFinished = true;
        ready = true;
        loadErrors ??= [];
        loadErrors.Add(new ProjectError(message));
    }

    bool Panicked => loadErrors?.Count > 0;
    
    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        
        if (!Consts.Cfg.Repository.IsNullOrWhiteSpace())
        {
            basePath = Consts.Cfg.Repository;
        }

        CommandManager.OnBeforeJump = () =>
        {
            JumpingInHistory = true;
            EnableRendering = false;
            return Task.CompletedTask;
        };

        CommandManager.OnAfterJump = () =>
        {
            JumpingInHistory = false;
            EnableRendering = true;
            StateHasChanged();
            return Task.CompletedTask;
        };

        CommandManager.OnBeforeRewindProgressCommand = (action, cmd) =>
        {
            if (RewindModalRef is not null)
            {
                RewindModalRef.Close();
                RewindModalRef = null;
            }
            
            RewindModalRef = Md.ShowModal<LocalizeActionRewindModal>(new
            {
                Owner = this,
                Action = action,
                Command = cmd
            });

            return Task.CompletedTask;
        };

        CommandManager.OnAfterRewindProgressCommand = (action, cmd) =>
        {
            if (RewindModalRef is not null)
            {
                RewindModalRef.Close();
                RewindModalRef = null;
            }
            
            return Task.CompletedTask;
        };
        
        await ShowLanguages(false);

        if (!Directory.Exists($"{basePath}/TeReo"))
        {
            Directory.CreateDirectory($"{basePath}/TeReo");
        }

        if (File.Exists($"{basePath}/TeReo/project.json"))
        {
            string currentData = await File.ReadAllTextAsync($"{basePath}/TeReo/project.json");
            Project = JsonSerializer.Deserialize<Project>(currentData) ?? new Project();
        }
        else
        {
            // old structure
            string currentData = await File.ReadAllTextAsync($"{basePath}/TeReo/decl.json");
            Decl oldDecl = JsonSerializer.Deserialize<Decl>(currentData) ?? new Decl();
            Project.Decls.Add(oldDecl);
        }

        if (Project.SchemaVersion != Project.LatestVersion)
        {
            string[] parts = Project.SchemaVersion.Split('.');

            if (parts.Length is not 3)
            {
                Panic($"Verze projektu {Project.SchemaVersion} není v platném formátu X.Y.Z");
                return;
            }

            if (!int.TryParse(parts[0], out int major))
            {
                Panic($"Část verze projektu {parts[0]} není platné číslo");
            }

            Project.VersionMajor = major;

            if (!int.TryParse(parts[1], out int minor))
            {
                Panic($"Část verze projektu {parts[1]} není platné číslo");
            }

            Project.VersionMinor = minor;

            if (!int.TryParse(parts[2], out int patch))
            {
                Panic($"Část verze projektu {parts[2]} není platné číslo");
            }

            Project.VersionPatch = patch;

            if (Panicked)
            {
                return;
            }

            if (major > Project.LatestVersionMajor || minor > Project.LatestVersionMinor)
            {
                Panic($"Verze TeReo, kterou používáte je zastaralá. Aktualizujte prosím z {Project.LatestVersionMajor}.{Project.LatestVersionMinor}.{Project.LatestVersionPatch} na ^{major}.{minor}.0 pro načtení tohoto projektu");
                return;
            }
        }
        else
        {
            Project.VersionMajor = Project.LatestVersionMajor;
            Project.VersionMinor = Project.LatestVersionMinor;
            Project.VersionPatch = Project.LatestVersionPatch;
        }

        if (Panicked)
        {
            return;
        }

        projectLoadingFinished = true;
        Project.SelectedDecl = Project.Decls.FirstOrDefault() ?? new Decl();

        if (File.Exists($"{basePath}/TeReo/userSettings.json"))
        {
            Settings = (await File.ReadAllTextAsync($"{basePath}/TeReo/userSettings.json")).JsonDecode<UserSettings>() ?? Settings;

            if (Settings.ShowLangs is not null)
            {
                foreach (KeyValuePair<Languages, LangData> x in LangsData.Langs)
                {
                    x.Value.Visible = Settings.ShowLangs.Contains(x.Key);
                }
            }
        }

        if (Consts.Cfg.Experimental)
        {
            synchronizingIndex = true;

            AsyncService.Fire(async () =>
            {
                Index.SynchronizeIndex(Decl.Keys.Select(x => new IndexDocument
                {
                    Id = x.Value.Id,
                    Content = x.Value.Name
                }).ToList());

                synchronizingIndex = false;
                StateHasChanged();
            });
        }

        foreach (Decl x in Project.Decls)
        {
            foreach (KeyValuePair<string, Key> key in x.Keys)
            {
                key.Value.Owner = x;
            }
        }

        if (!Settings.SelectedDecl.IsNullOrWhiteSpace())
        {
            Decl? matchingDecl = Project.Decls.FirstOrDefault(x => x.Id == Settings.SelectedDecl);

            if (matchingDecl is not null)
            {
                Project.SelectedDecl = matchingDecl;
            }
        }

        ApplySearch(true, false);
        ready = true;
    }

    public void ConditionallyClearSearch(string currentVal)
    {
        if (!KeySearch.IsNullOrWhiteSpace() && !KeySearch.Contains(currentVal))
        {
            KeySearch = string.Empty;
        }
    }

    public void SetSearch(string val)
    {
        KeySearch = val;
    }

    async Task DeleteLanguage()
    {
        if (langCode.IsNullOrWhiteSpace())
        {
            await Js.Toast(ToastTypes.Error, "Kód jazyka nemůže být prázdný");
            return;
        }
        
        string normalized = langCode.ToUpper().Trim();

        if (!Enum.TryParse(normalized, true, out Languages _))
        {
            await Js.Toast(ToastTypes.Error, $"Kód jazyka '{normalized}' není platný");
            return;
        }
        
        if (File.Exists($"{basePath}/TeReo/lang_{normalized}.json"))
        {
            File.Delete($"{basePath}/TeReo/lang_{normalized}.json");
            langCode = string.Empty;
            await ShowLanguages(false);
            StateHasChanged();
        }
        else
        {
            await Js.Toast(ToastTypes.Error, $"Jazyk '{normalized}' není přidán");
        }
    }

    async Task AddLanguage()
    {
        if (langCode.IsNullOrWhiteSpace())
        {
            await Js.Toast(ToastTypes.Error, "Kód jazyka nemůže být prázdný");
        }

        string normalized = langCode.ToUpper().Trim();

        if (!Enum.TryParse(normalized, true, out Languages _))
        {
            await Js.Toast(ToastTypes.Error, $"Kód jazyka '{normalized}' není platný");
            return;
        }
        
        if (!File.Exists($"{basePath}/TeReo/lang_{normalized}.json"))
        {
            await File.WriteAllTextAsync($"{basePath}/TeReo/lang_{normalized}.json", "{}");
            langCode = string.Empty;
            await ShowLanguages(false);
            StateHasChanged();
        }
        else
        {
            await Js.Toast(ToastTypes.Error, $"Jazyk '{normalized}' je již přidán");
        }
    }

    async Task ShowLanguages(bool showLanguages)
    {
        if (showLanguages)
        {
            showLangs = true;
        }

        existingFiles = Directory.GetFiles($"{basePath}/TeReo").ToList();
        LangsData.Langs.Clear();

        await Parallel.ForEachAsync(existingFiles, async (str, ctx) =>
        {
            string lang = Path.GetFileName(str).Replace(".json", string.Empty).Replace("lang_", string.Empty);

            if (!Enum.TryParse(lang, out Languages result))
            {
                return;
            }

            string data = await File.ReadAllTextAsync(str, ctx);
            LangData parsed = JsonSerializer.Deserialize<LangData>(data) ?? new LangData();
            parsed.PersistedData = new ConcurrentDictionary<string, string>(parsed.Data);
            LangsData.Langs.TryAdd(result, parsed);
        });

        if (showLanguages)
        {
            StateHasChanged();
        }
    }

    async Task AddKey()
    {
        if (JumpingInHistory)
        {
            return;
        }
        
        if (NewKey.IsNullOrWhiteSpace())
        {
            return;
        }

        DataOrException<bool> result = await Execute(new CmdAddKey(NewKey));

        if (result.Exception is not null)
        {
            await Js.Toast(ToastTypes.Error, result.Exception.Message);
        }
    }

    public async Task<DataOrException<bool>> Execute(ICommand cmd)
    {
        cmd.Ctx = GetCtx();
        DataOrException<bool> result = await CommandManager.Execute(cmd);
        StateHasChanged();
        return result;
    }

    public async Task SaveProject()
    {
        if (Project.NeedsUpgrade)
        {
            await Js.Toast(ToastTypes.Success, $"Schéma projektu aktualizováno z verze {Project.SchemaVersion} na verzi {Project.LatestVersion}");
            Project.SchemaVersion = Project.LatestVersion;
            Project.VersionMajor = Project.LatestVersionMajor;
            Project.VersionMinor = Project.LatestVersionMinor;
            Project.VersionPatch = Project.VersionPatch;
        }

        string data = Project.ToJson(true);
        await File.WriteAllTextAsync($"{basePath}/TeReo/project.json", data);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender)
        {
            return;
        }

        if (!JumpingInHistory)
        {
            if (InputToFocus is not null)
            {
                try
                {
                    bool focused = await Js.Focus(InputToFocus);

                    if (focused)
                    {
                        InputToFocus = null;
                    }
                }
                catch (Exception e)
                {
                }
            }   
        }

        if (ready && !jsInitialized && contentRendered)
        {
            jsInitialized = true;

            if (Consts.Cfg.Experimental)
            {
                try
                {
                    JsObjectRef = await Js.InvokeAsync<IJSObjectReference>("import", "./Scripts/Scoped/tabulator.js");
                    await JsObjectRef.InvokeVoidAsync("Init", new
                    {
                        id = id,
                        net = JsRef,
                        decl = Decl,
                        langs = LangsData
                    });
                }
                catch (Exception e)
                {
                }
            }
            else
            {
                try
                {
                    JsObjectRefNative = await Js.InvokeAsync<IJSObjectReference>("import", "./Scripts/Scoped/native.js");
                    await JsObjectRefNative.InvokeVoidAsync("Init", new
                    {
                        id = id,
                        net = JsRef,
                        settings = Settings
                    });
                }
                catch (Exception e)
                {
                }
            }
        }
        else if (jsInitialized)
        {
            if (nativeCommands.Count > 0 && JsObjectRefNative is not null && contentRendered)
            {
                try
                {
                    List<NativeCommand> copy = [..nativeCommands];
                    nativeCommands.Clear();

                    await JsObjectRefNative.InvokeVoidAsync("ProcessCommands", new
                    {
                        id = id,
                        commands = copy
                    });
                }
                catch (Exception e)
                {
                }
            }
        }
    }

    void SetKeyValue(Languages language, string key, string value)
    {
        LangData lang = LangsData.Langs[language];
        lang.Data[key] = value;
    }

    public async Task SetKey(Languages language, string key, string value)
    {
        SetKeyValue(language, key, value);
        
        if (Settings.TranslationMode is TranslationModes.Default)
        {
            await SaveLanguage(language);
        }
        else
        {
            foreach (KeyValuePair<Languages, LangData> x in LangsData.Langs.Where(x => x.Key != language))
            {
                x.Value.Data.TryRemove(key, out _);
            }

            await SaveLanguages();
        }
    }

    public void RecomputeVisibleKeys(bool resetPaging = false, string? keyToFocus = null)
    {
        visibleKeys.Clear();

        if (resetPaging)
        {
            keySelectedPage = 1;
            keyPages = 0;
        }

        IOrderedEnumerable<KeyValuePair<string, Key>> source = (Settings.KeySearchAllGroups ? Project.Decls.SelectMany(x => x.Keys) : Decl.Keys).OrderByDescending(x => x.Value.SearchPriority).ThenBy(x => x.Key, StringComparer.Ordinal);

        if (Settings.LimitRender <= 0)
        {
            foreach (KeyValuePair<string, Key> x in source)
            {
                if (x.Value.IsVisible)
                {
                    visibleKeys.Add(x);
                }
            }
        }
        else
        {
            List<KeyValuePair<string, Key>> keys = source.Where(x => x.Value.IsVisible).ToList();
            keyPages = (int)Math.Ceiling(keys.Count / (double)Settings.LimitRender);
            int take = Settings.LimitRender;

            if (keyToFocus is not null)
            {
                if (Decl.Keys.TryGetValue(keyToFocus, out Key? match))
                {
                    int index = keys.BinarySearch(new KeyValuePair<string, Key>(keyToFocus, match), Comparer<KeyValuePair<string, Key>>.Create((a, b) => string.Compare(a.Key, b.Key, StringComparison.Ordinal)));

                    if (index < 0)
                    {
                        index = ~index;
                    }

                    int indexPage = (int)Math.Ceiling((index + 1) / (double)take);
                    keySelectedPage = Math.Max(1, Math.Min(indexPage, keyPages));
                }
            }

            int skip = Settings.LimitRender * (keySelectedPage - 1);

            foreach (KeyValuePair<string, Key> x in keys.Skip(skip).Take(take))
            {
                visibleKeys.Add(x);
            }

            RecomputeVisibleInputHeights();
        }
    }

    public void RecomputeVisibleInputHeights()
    {
        if (Settings.RenderMode is RenderModes.Textarea)
        {
            nativeCommands.Add(new NativeCommand
            {
                Type = NativeCommands.SetTextareaHeight
            });
            
            StateHasChanged();
        }
    }

    void HandleKeyFocus(Languages language, string key, string value)
    {
        if (JumpingInHistory)
        {
            return;
        }
        
        LangsData.Langs[language].FocusData[key] = value;
    }

    async Task HandleKeyUpdate(Languages language, string key, string value)
    {
        if (JumpingInHistory)
        {
            return;
        }
        
        await Execute(new CmdSetKeyValue(language, key, value));
    }

    public async Task SaveLanguage(Languages language)
    {
        LangData source = LangsData.Langs[language];
        source.PersistedData = new ConcurrentDictionary<string, string>(source.Data);
        source.UncommitedChanges.Clear();
        StateHasChanged();

        string data = LangsData.Langs[language].ToJson();
        await File.WriteAllTextAsync($"{basePath}/TeReo/lang_{language}.json", data);
    }

    public async Task SaveLanguages()
    {
        await Parallel.ForEachAsync(LangsData.Langs, async (pair, token) =>
        {
            await SaveLanguage(pair.Key);
        });
    }

    async Task MoveKey(Key key)
    {
        Md.ShowModal<LocalizeMoveKeyModal>(new
        {
            Key = key,
            Owner = this
        });
    }

    async Task OpenSettingsKey(Key key)
    {
        Md.ShowModal<LocalizeSettingsKeyModal>(new
        {
            Key = key,
            Owner = this
        });
    }

    Task RegenerateKey(Key key)
    {
        Md.ShowModal<LocalizeRegenerateKeyModal>(new
        {
            Owner = this,
            Key = key
        });

        return Task.CompletedTask;
    }

    public async Task<DataOrException<bool>> DoRegenerateKey(string key, IProgress<CommandProgress>? progress = null)
    {
        if (!LangsData.Langs.TryGetValue(Project.Settings.PrimaryLanguage, out LangData? data))
        {
            return new DataOrException<bool>(new Exception($"Překlady v jazyce <code>{Project.Settings.PrimaryLanguage}</code> nejsou dostupné"));
        }
        
        if (data.Data.TryGetValue(key, out string? primaryValue))
        {
            string newKeyCopy = primaryValue.Trim().FirstLetterToUpper();
            string newKeyName = Localizer.BaseIdentifier(newKeyCopy);
            DataOrException<bool> result =  await RenameAndSaveKey(key, newKeyName, KeyRenameReasons.Regenerate, progress);

            return result;
        }

        return new DataOrException<bool>(new Exception($"Klíč nemá hodnotu v primárním jazyce <code>{Project.Settings.PrimaryLanguage}</code>"));
    }

    public async Task<DataOrException<bool>> RenameAndSaveKey(string key, string newKeyName, KeyRenameReasons reason, IProgress<CommandProgress>? progress = null)
    {
        return await Execute(new CmdRenameKey(key, newKeyName, reason, progress));
    }

    public void SetInputToFocus(string inputToFocus)
    {
        LastFocusedInput = inputToFocus;
        InputToFocus = inputToFocus;
    }

    async Task RenameKey(Key key)
    {
        Md.ShowModal<LocalizeRenameKeyModal>(new
        {
            Owner = this,
            Key = key
        });
    }

    public async Task DeleteKey(string key)
    {
        foreach (KeyValuePair<Languages, LangData> x in LangsData.Langs)
        {
            if (x.Value.Data.TryGetValue(key, out string? _))
            {
                x.Value.Data.TryRemove(key, out _);
            }
        }

        await SaveLanguages();

        if (Decl.Keys.TryGetValue(key, out Key? _))
        {
            Decl.Keys.TryRemove(key, out _);
            await SaveProject();
        }
    }

    async Task Delete(Key key)
    {
        Md.ShowConfirmActionModal($"Potvrďte odstranění klíče <code>{key.Name}</code>", async () =>
        {
            await Execute(new CmdDeleteKey(key.Name));
        });
    }

    public async Task Generate()
    {
        Localizer l = new Localizer(Project, LangsData);
        CodegenResult code = await l.Generate();

        if (code.Backend is not null)
        {
            string backendDir = $"{basePath}/I18N";
            string backendFile = $"{backendDir}/Reo.cs";
            
            Directory.CreateDirectory(backendDir);
            
            string[] existingBackendFiles = Directory.GetFiles(backendDir);
            
            foreach (string file in existingBackendFiles)
            {
                if (file != backendFile)
                {
                    File.Delete(file);
                }
            }
            
            await File.WriteAllTextAsync(backendFile, code.Backend);
        }

        if (code.Frontend.Decls.Count > 0 || code.Frontend.Declarations is not null)
        {
            string frontendDir = $"{basePath}/wwwroot/Scripts/reo";
            Directory.CreateDirectory(frontendDir);
            
            Dictionary<string, string> requiredFiles = new Dictionary<string, string>();

            if (code.Frontend.Declarations is not null)
            {
                requiredFiles[$"{frontendDir}/reo.d.ts"] = code.Frontend.Declarations;
            }

            if (code.Frontend.AmbientDeclarations is not null)
            {
                requiredFiles[$"{frontendDir}/reoAmbient.d.ts"] = code.Frontend.AmbientDeclarations;
            }

            if (code.Frontend.Mgr is not null)
            {
                requiredFiles[$"{frontendDir}/reolib.ts"] = code.Frontend.Mgr.Ts;
                requiredFiles[$"{frontendDir}/reolib.js"] = code.Frontend.Mgr.Js;
                requiredFiles[$"{frontendDir}/reolib.js.map"] = code.Frontend.Mgr.Map;
            }

            if (code.Frontend.Map is not null)
            {
                requiredFiles[$"{frontendDir}/reo.map.json"] = code.Frontend.Map;
            }

            if (code.Frontend.Tsconfig is not null)
            {
                requiredFiles[$"{frontendDir}/tsconfig.json"] = code.Frontend.Tsconfig;
            }
            
            foreach (KeyValuePair<Languages, string> pair in code.Frontend.Decls)
            {
                requiredFiles[$"{frontendDir}/reo.{pair.Key.ToString().ToLowerInvariant()}.json"] = pair.Value;
            }

            foreach (KeyValuePair<(Languages language, string decl), string> pair in code.Frontend.StandaloneDecls)
            {
                requiredFiles[$"{frontendDir}/{pair.Key.decl}.{pair.Key.language.ToString().ToLowerInvariant()}.json"] = pair.Value;
            }
            
            Dictionary<string, bool> localFiles = Directory.GetFiles(frontendDir, "*.*", SearchOption.AllDirectories).ToDictionary(f => f, f => true);
            
            foreach (string existingFile in localFiles.Keys.Where(x => !requiredFiles.ContainsKey(x)))
            {
                File.Delete(existingFile);
            }
            
            await Parallel.ForEachAsync(requiredFiles, async (pair, token) =>
            {
                await File.WriteAllTextAsync(pair.Key, pair.Value, token);
            });
        }

        await UpgradeProjectIfNeeded();
        await Js.Toast(ToastTypes.Success, "Kód vygenerován a zapsán");
        StateHasChanged();
    }

    async Task GenerateMissing()
    {
        if (Translating)
        {
            return;
        }

        ToTranslate.Clear();
        Translating = true;
        Translated = 0;
        StateHasChanged();

        DataOrException<bool> result = await Execute(new CmdGenerateMissingKeyValues());

        if (result.Exception is not null)
        {
            await Js.Toast(ToastTypes.Error, result.Exception.Message);
        }

        ToTranslate.Clear();
        Translated = 0;
        Translating = false;
        StateHasChanged();
    }

    async Task UpgradeProjectIfNeeded()
    {
        if (Project.NeedsUpgrade)
        {
            await SaveProject();
        }
    }

    async Task ForceSave()
    {
        await SaveProject();
        await SaveLanguages();
        await Js.Toast(ToastTypes.Success, "Projekt uložen");
    }

    async Task AfterSearchUpdate(string val)
    {
        KeySearch = val;
        await UpdateSearchResults();
    }

    Task UpdateSearchResults()
    {
        if (Consts.Cfg.Experimental)
        {
            foreach (KeyValuePair<string, Key> x in Decl.Keys)
            {
                x.Value.IsVisible = false;
            }

            List<SearchResult> results = Index.Search(KeySearch.ToBaseLatin());
            return Task.CompletedTask;
        }

        ApplySearch(true);
        StateHasChanged();
        return Task.CompletedTask;
    }

    async Task CycleTranslationMode()
    {
        if (Settings.TranslationMode < TranslationModes.Invalidate)
        {
            Settings.TranslationMode++;
        }
        else
        {
            Settings.TranslationMode = TranslationModes.Default;
        }

        await SaveUserSettings();
        StateHasChanged();
    }

    async Task CycleInputMode()
    {
        if (Settings.RenderMode < RenderModes.Textarea)
        {
            Settings.RenderMode++;
            nativeCommands.Add(new NativeCommand
            {
                Type = NativeCommands.SetTextareaHeight
            });
        }
        else
        {
            Settings.RenderMode = RenderModes.Input;
        }

        StateHasChanged();
        await SaveUserSettings();
    }
    
    public async ValueTask DisposeAsync()
    {
        if (JsObjectRef is not null)
        {
            try
            {
                await JsObjectRef.InvokeVoidAsync("Destroy", new
                {
                    id = id
                });

                await JsObjectRef.DisposeAsync();
            }
            catch (Exception e)
            {
            }
        }

        if (JsObjectRefNative is not null)
        {
            try
            {
                await JsObjectRefNative.InvokeVoidAsync("Destroy", new
                {
                    id = id
                });

                await JsObjectRefNative.DisposeAsync();
            }
            catch (Exception e)
            {
            }
        }
        
        JsRef?.Dispose();
    }

    async Task AfterLanguageToggle(KeyValuePair<Languages, LangData> local, bool visible)
    {
        local.Value.Visible = visible;
        Settings.ShowLangs = LangsData.Langs.Where(x => x.Value.Visible).Select(x => x.Key).ToList();
        await SaveUserSettings();
    }

    async Task AfterLimitUpdate(int value)
    {
        Settings.LimitRender = value;
        RecomputeVisibleKeys(true);
        StateHasChanged();
        await SaveUserSettings();
    }

    async Task SetKeyPage(int page)
    {
        keySelectedPage = page;
        RecomputeVisibleKeys();
        StateHasChanged();
    }

    async Task SetKeyPageJump()
    {
        string jumpToPageValue = await Js.InvokeAsync<string>("eval", $"document.getElementById('pageJumpEl').value");

        if (int.TryParse(jumpToPageValue, out int pageNumber) && pageNumber >= 1 && pageNumber <= keyPages)
        {
            await SetKeyPage(pageNumber);
            await Js.InvokeVoidAsync("eval", $"document.getElementById('pageJumpEl').value = ''");
        }
    }

    public async Task SaveUserSettings()
    {
        await File.WriteAllTextAsync($"{basePath}\\TeReo\\userSettings.json", Settings.ToJson());
    }

    Task EditDecl()
    {
        Md.ShowModal<LocalizeGroupSettingsModal>(new
        {
            Owner = this
        });
        
        return Task.CompletedTask;
    }

    Task RenameDecl()
    {
        Md.ShowPromptModal($"Nový název skupiny {Decl.Name}", string.Empty, async (str) =>
        {
            DataOrException<bool> result = await Execute(new CmdRenameGroup(str));

            if (result.Exception is not null)
            {
                await Js.Toast(ToastTypes.Error, result.Exception.Message);
            }
            
            StateHasChanged();
        }, defaultText: Decl.Name.IsNullOrWhiteSpace() ? string.Empty : Decl.Name);

        return Task.CompletedTask;
    }

    Task AddDecl()
    {
        Md.ShowPromptModal("Přidat skupinu", "Zadejte název nové skupiny", async (str) =>
        {
            DataOrException<bool> result = await Execute(new CmdAddGroup(str));

            if (result.Exception is not null)
            {
                await Js.Toast(ToastTypes.Error, result.Exception.Message);
            }
        });

        return Task.CompletedTask;
    }

    async Task DeleteDecl()
    {
        if (Project.Decls.Count <= 1)
        {
            await Js.Toast(ToastTypes.Error, "Skupinu je možné odstranit pouze pokud projekt obsahuje více než jednu skupinu");
            return;
        }
        
        Md.ShowConfirmActionModal($"Potvrďte odstranění skupiny '{Decl.Name}' (klíčů: {Decl.Keys.Count})", async () =>
        {
            DataOrException<bool> result = await Execute(new CmdDeleteGroup(Decl));

            if (result.Exception is not null)
            {
                await Js.Toast(ToastTypes.Error, result.Exception.Message);
            }

            StateHasChanged();
        });
    }

    async Task HandleKeySearchValueChange(ChangeEventArgs? args)
    {
        if (args?.Value is string str)
        {
            if (str is "null")
            {
                Settings.KeySearchLang = null;
            }
            else if (Enum.TryParse(str, true, out Languages parsed))
            {
                Settings.KeySearchLang = parsed;
            }
        }
        
        await UpdateSearchResults();
        await SaveUserSettings();
    }

    async Task HandleActiveDeclChange(ChangeEventArgs args)
    {
        if (args.Value is string str)
        {
            Decl? matchingDecl = Project.Decls.FirstOrDefault(x => x.Id == str);

            if (matchingDecl is not null)
            {
                Project.SelectedDecl = matchingDecl;
                Settings.SelectedDecl = str;
                await SaveUserSettings();

                ApplySearch(true);
                StateHasChanged();
            }
        }
    }

    static (bool contains, bool startsWith, bool exactMatch) CompareStrings(string source, string search, bool ignoreCase)
    {
        if (source.Length < search.Length)
        {
            return (false, false, false);
        }

        ReadOnlySpan<char> sourceSpan = source.AsSpan();
        ReadOnlySpan<char> searchSpan = search.AsSpan();

        bool startsWith = true;
        bool exactMatch = source.Length == search.Length;

        for (int i = 0; i < searchSpan.Length; i++)
        {
            if (!CharsEqual(sourceSpan[i], searchSpan[i], ignoreCase))
            {
                startsWith = false;
                exactMatch = false;
                break;
            }
        }

        if (startsWith)
        {
            return (true, true, exactMatch);
        }

        for (int i = 1; i <= sourceSpan.Length - searchSpan.Length; i++)
        {
            bool found = true;

            for (int j = 0; j < searchSpan.Length; j++)
            {
                if (!CharsEqual(sourceSpan[i + j], searchSpan[j], ignoreCase))
                {
                    found = false;
                    break;
                }
            }

            if (found)
            {
                return (true, false, false);
            }
        }

        return (false, false, false);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool CharsEqual(char c1, char c2, bool ignoreCase)
    {
        if (ignoreCase)
        {
            return char.ToUpperInvariant(c1) == char.ToUpperInvariant(c2);
        }

        return c1 == c2;
    }

    static readonly ParallelOptions FullDop = new ParallelOptions
    {
        MaxDegreeOfParallelism = Environment.ProcessorCount
    };

    public void ApplySearch(bool recomputeKeysAfter = false, bool resetPagingOnRecompute = true)
    {
        string searchTerm = Settings.KeySearchLang is null ? KeySearch.ToBaseLatin() : KeySearch;
        searchTerm = searchTerm.TrimStart();
        
        Parallel.ForEach(Settings.KeySearchAllGroups ? Project.Decls.SelectMany(x => x.Keys) : Decl.Keys, FullDop, item =>
        {
            item.Value.IsVisible = false;
            item.Value.SearchPriority = 0;

            string? keyToCompare = null;

            if (Settings.KeySearchLang is null)
            {
                keyToCompare = item.Key;
            }
            else
            {
                if (LangsData.Langs.TryGetValue(Settings.KeySearchLang.Value, out LangData? data))
                {
                    if (data.Data.TryGetValue(item.Key, out string? translatedKey))
                    {
                        keyToCompare = translatedKey;
                    }
                }
            }

            if (keyToCompare is null)
            {
                return;
            }

            if (searchTerm.Length is 0)
            {
                item.Value.IsVisible = true;
                item.Value.SearchPriority = 0;
                
                // when search is empty but "search in all groups" is enabled, consider as matches only keys from the active decl
                if (Settings.KeySearchAllGroups)
                {
                    if (item.Value.Owner != Decl)
                    {
                        item.Value.IsVisible = false;
                    }
                }
                
                return;
            }

            (bool contains, bool startsWith, bool exactMatch) = CompareStrings(keyToCompare, searchTerm, true);

            bool isMatch = Settings.KeySearchMode switch
            {
                KeySearchModes.Unknown or KeySearchModes.Contains => contains,
                KeySearchModes.Exact => exactMatch,
                _ => false
            };

            if (isMatch)
            {
                item.Value.IsVisible = true;
                item.Value.SearchPriority = exactMatch ? 2 : startsWith ? 1 : 0;
            }
        });

        if (recomputeKeysAfter)
        {
            RecomputeVisibleKeys(resetPagingOnRecompute);   
        }
    }

    public async Task TransferKey(Key key, Decl newOwner)
    {
        await Execute(new CmdMoveKey(key.Name, key.Owner, newOwner));
    }

    async Task KeySearchModeSelected(KeySearchModes mode)
    {
        Settings.KeySearchMode = mode;
        await UpdateSearchResults();
        await SaveUserSettings();
    }

    void ToggleSearchModeSelection()
    {
        renderSearchModeSelection = !renderSearchModeSelection;
        StateHasChanged();
    }

    void ShowAppSettings()
    {
        Md.ShowModal<AppSettingsModal>(new
        {
            Owner = this
        });
    }

    void ShowHistory()
    {
        Md.ShowModal<LocalizeHistoryModal>(new
        {
            Owner = this
        });
    }

    void ToggleUncommitedChangesDetail()
    {
        Settings.ShowUncommitedChangesDetail = !Settings.ShowUncommitedChangesDetail;
        StateHasChanged();
    }

    async Task DiscardChange(Languages language, string key)
    {
        Md.ShowConfirmActionModal("Zahodit změnu", $"Potvrďte zahození změny na klíči <code>{key}</code>", async () =>
        {
            LangData lang = LangsData.Langs[language];

            if (lang.PersistedData.TryGetValue(key, out string? persistedVal))
            {
                lang.Data[key] = persistedVal;
            }
            else
            {
                lang.Data.TryRemove(key, out _);
            }

            lang.UncommitedChanges.TryRemove(key, out _);
            StateHasChanged();
        });
    }

    async Task Undo()
    {
        if (CommandManager.CanUndo)
        {
            await CommandManager.Undo();
            StateHasChanged();
        }
    }

    async Task Redo()
    {
        if (CommandManager.CanRedo)
        {
            await CommandManager.Redo();
            StateHasChanged();
        }
    }

    public async Task JumpTo(HistoryItem item)
    {
        await CommandManager.Jump(item);
        StateHasChanged();
    }

    void ToggleLangsSelection()
    {
        showLangsSelection = !showLangsSelection;
        StateHasChanged();
    }

    void ToggleLangsAdd()
    {
        showAddLangs = !showAddLangs;
        StateHasChanged();
    }

    void ToggleGroupSettings()
    {
        showGroupSettings = !showGroupSettings;
        StateHasChanged();
    }

    async Task HandleKeyAddKeyPressed(KeyboardEventArgs args)
    {
        if (args.Code == "Enter")
        {
            await AddKey();
        }
    }

    async Task HandleEditorClick(Languages language, string key, string value)
    {
        string? freshValue = null;
        
        try
        {
            // the value reported here is possibly stale, if the value has been edited prior to clicking the RTE icon without blur event happening interim
            freshValue = await Js.InvokeAsync<string?>("mcf.getElementValue", $"input_{language}_{key}");
        }
        catch (Exception e)
        {
            
        }
        
        Md.ShowModal<LocalizeKeyEditorModal>(new
        {
            Owner = this,
            Language = language,
            Key = key,
            Value = freshValue ?? value
        });
    }
}

@if (!projectLoadingFinished)
{
    return;
}

@if (Panicked)
{
    <div>Projekt není možné načíst kvůli následujícím chybám:</div>
    <ul>
        @foreach (ProjectError x in loadErrors ?? [])
        {
            <li>@x.Message</li>
        }
    </ul>

    return;
}

<SectionContent SectionName="menuBar">
    <div style="display: flex; gap: 100px; width: 100%; justify-content: space-between; flex-flow: wrap; row-gap: 0; padding-top: 1rem; padding-bottom: 0.5rem;">
    
        @if (LangsData.Langs.Count is 0)
        {
            <div>Lokalizace se načítá..</div>
        }
        else
        {
            List<KeyValuePair<Languages, LangData>> visible = LangsData.Langs.Where(x => x.Value.Visible).ToList();
            
            <div>
                <div style="display: flex; gap: 15px;">

                    <div>
                        <button @onclick="ToggleLangsSelection" style="white-space: nowrap;" class="btn btn-secondary btn-sm">Zobrazit: @(visible.Count is 0 ? "žádné jazyky" : visible.Count == LangsData.Langs.Count ? "všechny jazyky" : $"{visible.Select(x => x.Key.ToString()).ToCsv(", ")}")</button>

                        @if (showLangsSelection)
                        {
                            <div style="display: flex; gap: 15px; margin-bottom: 10px; margin-top: 10px;">
                                @foreach (KeyValuePair<Languages, LangData> local in LangsData.Langs.OrderBy(y => y.Key.ToString(), StringComparer.Ordinal))
                                {
                                    <div class="form-check" @onclick="@(async () => { local.Value.Visible = !local.Value.Visible; await AfterLanguageToggle(local, local.Value.Visible); })">
                                        <input style="cursor: pointer;" @onclick:stopPropagation="true" @bind:set="@(async (value) => await AfterLanguageToggle(local, value))" @bind:get="local.Value.Visible" class="form-check-input" type="checkbox" id="@($"langShow_{local.Key}")"/>
                                        <label style="cursor: pointer; user-select: none;" class="form-check-label" for="@($"langShow_{local.Key}")">@local.Key</label>
                                    </div>
                                }
                            </div>
                            
                            <div style="margin-bottom: 10px;">
                                <div style="white-space: nowrap;" class="link-light" @onclick="ToggleLangsAdd">Nastavení jazyků</div>
                            </div>
                            
                            if (showAddLangs)
                            {
                                <div style="display: flex; gap: 10px; align-items: flex-start;">
                                    <input class="form-control form-control-sm" @bind="langCode" placeholder="Kód jazyka"/>
                                    <button style="white-space: nowrap;" class="btn btn-secondary btn-sm" @onclick="AddLanguage">Přidat jazyk</button>
                                    <button style="white-space: nowrap;" class="btn btn-danger btn-sm" @onclick="DeleteLanguage">Odebrat jazyk</button>
                                </div>   
                            }
                        }
                    </div>
                </div>
            </div>
        }
        
        <div>
            <div style="display: flex; gap: 10px; align-items: flex-start;">
                <input @bind:event="oninput" @bind:set="AfterSearchUpdate" @bind:get="KeySearch" class="form-control form-control-sm" placeholder="Hledat"/>
                <button @onclick="ToggleSearchModeSelection" style="white-space: nowrap;" class="btn btn-secondary btn-sm">Režim: @(Settings.KeySearchLang is null ? "klíč" : Settings.KeySearchLang.ToString()) @Settings.KeySearchMode.GetStringValue().FirstLetterToLower()</button>
            </div>

            @if (renderSearchModeSelection)
            {
                <div style="display: flex; gap: 10px; align-items: flex-start; flex-flow: column; margin-top: 10px;">
                    <div style="width: 100%;">
                        <div style="display: flex; gap: 10px; flex-flow: wrap;">
                            <select style="width: 160px;" @onchange="HandleKeySearchValueChange" class="form-select">
                                <option value="null" id="lang_search_key_name" selected="@(Settings.KeySearchLang is null)">Název klíče</option>

                                @foreach (KeyValuePair<Languages, LangData> local in LangsData.Langs.OrderBy(y => y.Key))
                                {
                                    <option value="@local.Key" id="lang_search_value_@local.Key" selected="@(Settings.KeySearchLang == local.Key)">Překlad @local.Key</option>
                                }
                            </select>

                            <EdCheckbox OnUpdate="@(async (sender) => await HandleKeySearchValueChange(null))" @bind-Value="Settings.KeySearchAllGroups" Label="Všechny skupiny" />
                        </div>

                        <div style="height: 6px;"></div>

                        <div class="form-check">
                            <input checked="@(Settings.KeySearchMode is KeySearchModes.Contains)" @onchange="@(async () => await KeySearchModeSelected(KeySearchModes.Contains))" class="form-check-input" id="searchTypeContains" type="radio" name="searchType"/>
                            <label class="form-check-label" for="searchTypeContains">@KeySearchModes.Contains.GetStringValue()</label>
                        </div>

                        <div class="form-check">
                            <input checked="@(Settings.KeySearchMode is KeySearchModes.Exact)" @onchange="@(async () => await KeySearchModeSelected(KeySearchModes.Exact))" class="form-check-input" id="searchTypeExact" type="radio" name="searchType"/>
                            <label class="form-check-label" for="searchTypeExact">@KeySearchModes.Exact.GetStringValue()</label>
                        </div>
                    </div>
                </div>
            }

        </div>

        <div style="display: flex; flex-flow: wrap; align-items: flex-start; gap: 5px; justify-content: flex-start; row-gap: 5px; height: fit-content;">
            <button class="btn btn-secondary btn-sm" @onclick="Generate">Generovat kód</button>
            <button class="btn btn-secondary btn-sm" @onclick="GenerateMissing">Doplnit chybějící překlady</button>
            <button class="btn btn-secondary btn-sm" @onclick="ForceSave">@(Settings.AutoSave ? "Vynutit uložení" : "Uložit změny")</button>
            <button class="@($"btn btn-sm {(Settings.TranslationMode is TranslationModes.Invalidate ? "btn-danger" : "btn-secondary")}")" @onclick="CycleTranslationMode">Zápis: @(Settings.TranslationMode.GetStringValue().FirstLetterToLower())</button>
        </div>

        <div style="display: flex; gap: 10px; align-items: flex-start;">
            <div style="display: flex; gap: 5px;">
                <button title="Zpět" class="btn btn-secondary btn-sm @(CommandManager.CanUndo ? string.Empty : "visuallyDisabled")" @onclick="Undo">
                    <img ondragstart="return false;" width="24" height="24" src="/Images/Svg/undo.svg" alt=""/>
                </button>
                <button title="Dopředu" class="btn btn-secondary btn-sm @(CommandManager.CanRedo ? string.Empty : "visuallyDisabled")" @onclick="Redo">
                    <img ondragstart="return false;" width="24" height="24" src="/Images/Svg/redo.svg" alt=""/>
                </button>

                @if (CommandManager.AnyHistory)
                {
                    <button class="btn btn-secondary btn-sm" @onclick="ShowHistory">Historie</button>
                }
            </div>
        </div>

        <div style="display: flex; gap: 10px; align-items: flex-start; flex: 1;">
            <button style="white-space: nowrap;" class="btn btn-secondary btn-sm" @onclick="AddKey">Přidat klíč</button>
            <input class="form-control form-control-sm" @bind="NewKey" @onkeyup="@(async (args) => await HandleKeyAddKeyPressed(args))" placeholder="Klíč"/>
        </div>
    </div>
</SectionContent>

@if (Translating)
{
    <p>Probíhá překlad @(Translated)/@(ToTranslate.Count)</p>
}

<div id="@id"></div>

@if (ready && !Consts.Cfg.Experimental)
{
    <div style="max-height: 800px; overflow: auto;">
        <table id="@($"table_{id}")" class="table table-sm table-bordered table-responsive tableMain tableSticky">
            <thead>
            <tr>
                <th style="width: 125px;">
                    <b>Akce</b>
                </th>
                <th data-rtc-resizable="key" style="width: 300px;">
                    <b>Klíč</b>
                </th>

                @foreach (KeyValuePair<Languages, LangData> local in LangsData.Langs.OrderBy(y => y.Key))
                {
                    if (!local.Value.Visible)
                    {
                        continue;
                    }

                    <th data-rtc-resizable="@local.Key">
                        <b>@local.Key</b>
                    </th>
                }
            </tr>
            </thead>
            <tbody>
            @foreach (KeyValuePair<string, Key> x in visibleKeys)
            {
                <tr>
                    <td>
                        <div>
                            <div class="dropdown">
                                <button class="btn btn-sm btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" data-bs-strategy="fixed" data-bs-boundary="window">Zobrazit akce</button>
                                <ul class="dropdown-menu">
                                    <li>
                                        <span style="cursor: pointer; user-select: none;" class="dropdown-item" @onclick="@(async () => await RenameKey(x.Value))">Přejmenovat</span>
                                    </li>

                                    <li>
                                        <span style="cursor: pointer; user-select: none;" class="dropdown-item" @onclick="@(async () => await RegenerateKey(x.Value))">Přegenerovat název klíče</span>
                                    </li>

                                    <li>
                                        <span style="cursor: pointer; user-select: none;" class="dropdown-item" @onclick="@(async () => await OpenSettingsKey(x.Value))">Nastavení</span>
                                    </li>

                                    @if (Project.Decls.Count > 1)
                                    {
                                        <li>
                                            <span style="cursor: pointer; user-select: none;" class="dropdown-item" @onclick="@(async () => await MoveKey(x.Value))">Přesunout</span>
                                        </li>
                                    }

                                    <li>
                                        <hr class="dropdown-divider">
                                    </li>
                                    <li>
                                        <span style="cursor: pointer; user-select: none;" class="dropdown-item" @onclick="@(async () => await Delete(x.Value))">Odstranit</span>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </td>
                    <td style="width: 300px;">
                        <div style="max-width: 300px;">
                            <code>@x.Key</code>

                            @if (!x.Value.AutoTranslatable)
                            {
                                <div>
                                    <code style="font-size: 12px;">[Manuální překlad]</code>
                                </div>
                            }
                            
                            @if (Settings.KeySearchAllGroups)
                            {
                                <div>
                                    <code style="font-size: 12px; color: #FF851B;">[Skupina: @x.Value.Owner.Name]</code>
                                </div>
                            }
                        </div>
                    </td>

                    @foreach (KeyValuePair<Languages, LangData> local in LangsData.Langs.OrderBy(y => y.Key.ToString(), StringComparer.Ordinal))
                    {
                        if (!local.Value.Visible)
                        {
                            continue;
                        }

                        string str = local.Value.Data.GetValueOrDefault(x.Key, string.Empty);
                        string langKey = local.Key.ToString().ToLowerInvariant();

                        <td>
                                <div style="position: relative;" class="keyEditorWrapper input-group">

                                    @if (Settings.RenderMode is RenderModes.Input)
                                    {
                                        <input lang="@langKey" data-gramm="false" data-gramm_editor="false" data-enable-grammarly="false" @key="@($"input_{local.Key}_{x.Key}")" id="@($"input_{local.Key}_{x.Key}")" class="form-control form-control-md" @onfocus="@(() => HandleKeyFocus(local.Key, x.Key, str))"  @onblur="@(async () => await HandleKeyUpdate(local.Key, x.Key, str))" @bind="str" @bind:after="@(() => SetKeyValue(local.Key, x.Key, str))"/>
                                    }
                                    else
                                    {
                                        <textarea style="padding-right: 20px;" lang="@langKey" data-gramm="false" data-gramm_editor="false" data-enable-grammarly="false" @key="@($"input_{local.Key}_{x.Key}")" id="@($"input_{local.Key}_{x.Key}")" class="keyEditorTextarea form-control form-control-md" @onfocus="@(() => HandleKeyFocus(local.Key, x.Key, str))" @onblur="@(async () => await HandleKeyUpdate(local.Key, x.Key, str))" @bind="str" @bind:after="@(() => SetKeyValue(local.Key, x.Key, str))"></textarea>
                                        <div @onmousedown="@(async () => await HandleEditorClick(local.Key, x.Key, str))" @onclick:stopPropagation="true" style="position: absolute; right: 2px; top: 2px; z-index: 10; width: 14px; height: 14px;" title="Otevřít v editoru" class="keyEditorIcon keyEditorIconElement svg-icon" >
                                            <svg style="vertical-align: top;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M432.4 787.2c-24.1 27.6-34.7 34.2-68.4 46.6-51.9 19.4-147 55.1-208.9 78.3-11.7 4.6-55.9 2.3-37.4-41.1 21-60.4 51.8-149.6 69.4-200.5 12.8-35.9 17.9-45.2 43.7-69.3l266.5-266.5L686 523.4C686 523.4 506.6 710.1 432.4 787.2z"  /><path d="M726.5 482.9 537.9 294.3 578.3 253.8 767 442.5Z"  /><path d="M888.3 321.2l-80.8 80.9L618.8 213.4l80.9-80.8c29.8-29.8 78-29.8 107.8 0l80.9 80.8C918.1 243.1 918.1 291.4 888.3 321.2z"  /></svg>
                                        </div>
                                    }
                                </div>
                        </td>
                    }
                </tr>
            }
            </tbody>
        </table>
    </div>

    if (!contentRendered)
    {
        contentRendered = true;
        StateHasChanged();
    }
}

@if (ready)
{
    <div class="bottomMenuBar" style="margin-top: 1rem; display: flex; gap: 100px; flex-flow: wrap; row-gap: 0;">
        <div>
            <div style="width: 280px;">
                <div style="margin-bottom: 5px;">
                    <select @onchange="HandleActiveDeclChange" class="form-select">
                        @foreach (Decl x in Project.Decls)
                        {
                            <option value="@x.Id" selected="@(x == Decl)">@(x.Name.IsNullOrWhiteSpace() ? "Skupina bez názvu" : $"{x.Name} (klíčů: {x.Keys.Count})")</option>
                        }
                    </select>
                </div>
                
                <div @onclick="ToggleGroupSettings" style="margin-bottom: 10px;" class="link-light">Správa skupin</div>
                
                @if (showGroupSettings)
                {
                    <div style="display: flex; flex-flow: wrap; gap: 5px; margin-bottom: 5px;">
                        <button class="@($"btn btn-sm btn-secondary")" @onclick="RenameDecl">Přejmenovat skupinu</button>
                        <button class="@($"btn btn-sm btn-secondary")" @onclick="AddDecl">Přidat skupinu</button>
                        <button class="@($"btn btn-sm btn-secondary")" @onclick="EditDecl">Upravit skupinu</button>
                        <button class="@($"btn btn-sm btn-danger")" @onclick="DeleteDecl">Odstranit skupinu</button>
                    </div>   
                }
            </div>
        </div>

        <div style="width: 250px;">
            <button class="@($"btn btn-sm btn-secondary")" @onclick="CycleInputMode">Zobrazení: @(Settings.RenderMode.GetStringValue().FirstLetterToLower())</button>
        </div>

        <div style="display: flex; gap: 20px; flex: 1; flex-flow: wrap;">
            <div style="display: flex; justify-content: flex-start; flex: 1; align-items: flex-start; gap: 20px; flex-flow: wrap;">
                <div style="display: flex; gap: 15px;">
                    <div title="0 pro zobrazení všech klíčů" style="white-space: nowrap; cursor: help; margin-top: auto; margin-bottom: auto;" class="form-label">Zobrazit klíčů:</div>
                    <input style="width: 100px;" type="number" class="form-control" id="limitRender" @bind:set="AfterLimitUpdate" @bind:get="Settings.LimitRender">
                </div>

                @if (keyPages > 1)
                {
                    <div class="d-flex align-items-center flex-wrap">
                        <div class="me-2">Strana:</div>
                        <ul class="pagination flex-wrap me-3" style="margin-bottom: 0;">
                            @{
                                int offset = 3;
                                
                                int start = Math.Max(1, keySelectedPage - offset);
                                int end = Math.Min(keyPages, keySelectedPage + offset);

                                if (start > 1)
                                {
                                    <li style="user-select: none; cursor: pointer;" class="page-item">
                                        <span class="page-link" @onclick="@(async () => await SetKeyPage(1))">1</span>
                                    </li>

                                    if (start > 2)
                                    {
                                        <li class="page-item disabled">
                                            <span class="page-link">...</span>
                                        </li>
                                    }
                                }

                                for (int i = start; i <= end; i++)
                                {
                                    int pageIndex = i;
                                    <li style="user-select: none; cursor: pointer;" @onclick="@(async () => await SetKeyPage(pageIndex))" class="page-item @(pageIndex == keySelectedPage ? "active" : string.Empty)">
                                        <span class="page-link">@pageIndex</span>
                                    </li>
                                }

                                if (end < keyPages)
                                {
                                    if (end < keyPages - 1)
                                    {
                                        <li class="page-item disabled">
                                            <span class="page-link">...</span>
                                        </li>
                                    }

                                    <li style="user-select: none; cursor: pointer;" class="page-item">
                                        <span class="page-link" @onclick="@(async () => await SetKeyPage(keyPages))">@keyPages</span>
                                    </li>
                                }
                            }
                        </ul>
                        <div class="d-flex align-items-center">
                            <input type="number" class="form-control me-2" style="width: 120px;" placeholder="Stránka" @ref="jumpToPageInput" id="pageJumpEl" min="1" max="@keyPages"/>
                            <button class="btn btn-outline-primary" @onclick="SetKeyPageJump">Přejít</button>
                        </div>
                    </div>
                }
            </div>
        </div>

        <div style="margin-left: auto; margin-right: 40px;">
            <div style="display: flex; flex-flow: wrap; gap: 5px; margin-bottom: 1rem;">
                <button class="btn btn-secondary btn-sm" @onclick="ShowAppSettings">Nastavení</button>
            </div>

            @if (synchronizingIndex)
            {
                <div style="margin-left: auto;">
                    <div>Probíhá synchronizace indexu..</div>
                </div>
            }
        </div>

    </div>
}